package e2eutils

import (
	"math/big"
	"os"
	"path"
	//"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rpc"
	"github.com/stretchr/testify/require"

	"github.com/ethereum-optimism/optimism/op-chain-ops/genesis"
	"github.com/ethereum-optimism/optimism/op-e2e/config"
	"github.com/ethereum-optimism/optimism/op-node/eth"
	"github.com/ethereum-optimism/optimism/op-node/rollup"
)

var testingJWTSecret = [32]byte{123}

// WriteDefaultJWT writes a testing JWT to the temporary directory of the test and returns the path to the JWT file.
func WriteDefaultJWT(t TestingBase) string {
	// Sadly the geth node config cannot load JWT secret from memory, it has to be a file
	jwtPath := path.Join(t.TempDir(), "jwt_secret")
	if err := os.WriteFile(jwtPath, []byte(hexutil.Encode(testingJWTSecret[:])), 0600); err != nil {
		t.Fatalf("failed to prepare jwt file for geth: %v", err)
	}
	return jwtPath
}

func uint64ToBig(in uint64) *hexutil.Big {
	return (*hexutil.Big)(new(big.Int).SetUint64(in))
}

// DeployParams bundles the deployment parameters to generate further testing inputs with.
type DeployParams struct {
	DeployConfig   *genesis.DeployConfig
	MnemonicConfig *MnemonicConfig
	Secrets        *Secrets
	Addresses      *Addresses
}

// TestParams parametrizes the most essential rollup configuration parameters
type TestParams struct {
	MaxSequencerDrift   uint64
	SequencerWindowSize uint64
	ChannelTimeout      uint64
	L1BlockTime         uint64
}

func MakeDeployParams(t require.TestingT, tp *TestParams) *DeployParams {
	mnemonicCfg := DefaultMnemonicConfig
	secrets, err := mnemonicCfg.Secrets()
	require.NoError(t, err)
	addresses := secrets.Addresses()

	deployConfig := config.DeployConfig.Copy()
	deployConfig.L2BlockTime = 2
	deployConfig.MaxSequencerDrift = tp.MaxSequencerDrift
	deployConfig.SequencerWindowSize = tp.SequencerWindowSize
	deployConfig.ChannelTimeout = tp.ChannelTimeout
	//deployConfig.L2OutputOracleStartingTimestamp = -1
	deployConfig.L1BlockTime = tp.L1BlockTime

	/*
		deployConfig.L2GenesisBlockNonce = 0
		deployConfig.L2GenesisBlockGasLimit = 30_000_000
		deployConfig.L2GenesisBlockDifficulty = uint642big(0)
		deployConfig.L2GenesisBlockMixHash = common.Hash{}
		deployConfig.L2GenesisBlockNumber = 0
		deployConfig.L2GenesisBlockGasUsed = 0
		deployConfig.L2GenesisBlockParentHash = common.Hash{}
		deployConfig.L2GenesisBlockBaseFeePerGas = uint642big(1000_000_000)
		deployConfig.FundDevAccounts = false
	*/
	require.Equal(t, deployConfig.EIP1559Elasticity, uint64(10))
	require.Equal(t, deployConfig.EIP1559Denominator, uint64(50))

	require.NotEqual(t, deployConfig.OptimismPortalProxy, common.Address{})
	require.NotEqual(t, deployConfig.SystemConfigProxy, common.Address{})
	require.NotEqual(t, deployConfig.L1ERC721BridgeProxy, common.Address{})
	require.NotEqual(t, deployConfig.L1CrossDomainMessengerProxy, common.Address{})
	require.NotEqual(t, deployConfig.L1StandardBridgeProxy, common.Address{})

	return &DeployParams{
		DeployConfig:   deployConfig,
		MnemonicConfig: mnemonicCfg,
		Secrets:        secrets,
		Addresses:      addresses,
	}
}

// SetupData bundles the L1, L2, rollup and deployment configuration data: everything for a full test setup.
type SetupData struct {
	L1Cfg         *core.Genesis
	L2Cfg         *core.Genesis
	RollupCfg     *rollup.Config
	DeploymentsL1 config.Deployments
}

// AllocParams defines genesis allocations to apply on top of the genesis generated by deploy parameters.
// These allocations override existing allocations per account,
// i.e. the allocations are merged with AllocParams having priority.
type AllocParams struct {
	L1Alloc          core.GenesisAlloc
	L2Alloc          core.GenesisAlloc
	PrefundTestUsers bool
}

var etherScalar = new(big.Int).Exp(big.NewInt(10), big.NewInt(18), nil)

// Ether converts a uint64 Ether amount into a *big.Int amount in wei units, for allocating test balances.
func Ether(v uint64) *big.Int {
	return new(big.Int).Mul(new(big.Int).SetUint64(v), etherScalar)
}

// Setup computes the testing setup configurations from deployment configuration and optional allocation parameters.
func Setup(t require.TestingT, deployParams *DeployParams, alloc *AllocParams) *SetupData {
	deployConf := deployParams.DeployConfig

	dump := config.L1Allocs
	l1Genesis, err := genesis.BuildL1DeveloperGenesis(deployConf, dump)
	require.NoError(t, err, "failed to create l1 genesis")
	if alloc.PrefundTestUsers {
		for _, addr := range deployParams.Addresses.All() {
			l1Genesis.Alloc[addr] = core.GenesisAccount{
				Balance: Ether(1e12),
			}
		}
	}
	for addr, val := range alloc.L1Alloc {
		l1Genesis.Alloc[addr] = val
	}

	l1Block := l1Genesis.ToBlock()

	l2Genesis, err := genesis.BuildL2Genesis(deployConf, l1Block)
	require.NoError(t, err, "failed to create l2 genesis")
	if alloc.PrefundTestUsers {
		for _, addr := range deployParams.Addresses.All() {
			l2Genesis.Alloc[addr] = core.GenesisAccount{
				Balance: Ether(1e12),
			}
		}
	}
	for addr, val := range alloc.L2Alloc {
		l2Genesis.Alloc[addr] = val
	}

	rollupCfg := &rollup.Config{
		Genesis: rollup.Genesis{
			L1: eth.BlockID{
				Hash:   l1Block.Hash(),
				Number: 0,
			},
			L2: eth.BlockID{
				Hash:   l2Genesis.ToBlock().Hash(),
				Number: 0,
			},
			L2Time:       uint64(deployConf.L1GenesisBlockTimestamp),
			SystemConfig: SystemConfigFromDeployConfig(deployConf),
		},
		BlockTime:              deployConf.L2BlockTime,
		MaxSequencerDrift:      deployConf.MaxSequencerDrift,
		SeqWindowSize:          deployConf.SequencerWindowSize,
		ChannelTimeout:         deployConf.ChannelTimeout,
		L1ChainID:              new(big.Int).SetUint64(deployConf.L1ChainID),
		L2ChainID:              new(big.Int).SetUint64(deployConf.L2ChainID),
		BatchInboxAddress:      deployConf.BatchInboxAddress,
		DepositContractAddress: deployConf.OptimismPortalProxy,
		L1SystemConfigAddress:  deployConf.SystemConfigProxy,
		RegolithTime:           deployConf.RegolithTime(uint64(deployConf.L1GenesisBlockTimestamp)),
	}

	// Sanity check that the config is correct
	require.Equal(t, deployParams.Secrets.Addresses().Batcher, deployParams.DeployConfig.BatchSenderAddress)
	require.Equal(t, deployParams.Secrets.Addresses().SequencerP2P, deployParams.DeployConfig.P2PSequencerAddress)
	require.Equal(t, deployParams.Secrets.Addresses().Proposer, deployParams.DeployConfig.L2OutputOracleProposer)

	return &SetupData{
		L1Cfg:         l1Genesis,
		L2Cfg:         l2Genesis,
		RollupCfg:     rollupCfg,
		DeploymentsL1: config.L1Deployments,
	}
}

func SystemConfigFromDeployConfig(deployConfig *genesis.DeployConfig) eth.SystemConfig {
	return eth.SystemConfig{
		BatcherAddr: deployConfig.BatchSenderAddress,
		Overhead:    eth.Bytes32(common.BigToHash(new(big.Int).SetUint64(deployConfig.GasPriceOracleOverhead))),
		Scalar:      eth.Bytes32(common.BigToHash(new(big.Int).SetUint64(deployConfig.GasPriceOracleScalar))),
		GasLimit:    uint64(deployConfig.L2GenesisBlockGasLimit),
	}
}

// ForkedDeployConfig returns a deploy config that's suitable for use with a
// forked L1.
// TODO: where is this used?
func ForkedDeployConfig(t require.TestingT, mnemonicCfg *MnemonicConfig, startBlock *types.Block) *genesis.DeployConfig {
	startTag := rpc.BlockNumberOrHashWithHash(startBlock.Hash(), true)
	secrets, err := mnemonicCfg.Secrets()
	require.NoError(t, err)
	addrs := secrets.Addresses()
	marshalable := genesis.MarshalableRPCBlockNumberOrHash(startTag)
	out := &genesis.DeployConfig{
		L1StartingBlockTag:               &marshalable,
		L1ChainID:                        1,
		L2ChainID:                        10,
		L2BlockTime:                      2,
		MaxSequencerDrift:                3600,
		SequencerWindowSize:              100,
		ChannelTimeout:                   40,
		P2PSequencerAddress:              addrs.SequencerP2P,
		BatchInboxAddress:                common.HexToAddress("0xff00000000000000000000000000000000000000"),
		BatchSenderAddress:               addrs.Batcher,
		FinalSystemOwner:                 addrs.SysCfgOwner,
		L1GenesisBlockDifficulty:         uint64ToBig(0),
		L1GenesisBlockBaseFeePerGas:      uint64ToBig(0),
		L2OutputOracleSubmissionInterval: 10,
		L2OutputOracleStartingTimestamp:  int(startBlock.Time()),
		L2OutputOracleProposer:           addrs.Proposer,
		L2OutputOracleChallenger:         addrs.Deployer,
		L2GenesisBlockGasLimit:           hexutil.Uint64(15_000_000),
		// taken from devnet, need to check this
		L2GenesisBlockBaseFeePerGas: uint64ToBig(0x3B9ACA00),
		L2GenesisBlockDifficulty:    uint64ToBig(0),
		L1BlockTime:                 12,
		FinalizationPeriodSeconds:   2,
		DeploymentWaitConfirmations: 1,
		EIP1559Elasticity:           10,
		EIP1559Denominator:          50,
		GasPriceOracleOverhead:      2100,
		GasPriceOracleScalar:        1_000_000,
		FundDevAccounts:             true,
	}
	return out
}

func uint642big(in uint64) *hexutil.Big {
	b := new(big.Int).SetUint64(in)
	hu := hexutil.Big(*b)
	return &hu
}
